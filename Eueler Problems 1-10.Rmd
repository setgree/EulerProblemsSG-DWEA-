---
title: "Euler Problems"
author: "Seth Green"
date: "March 20, 2016"
output: html_document
---

### Euler Problem 1

**If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.**

it'll be like, for in in n, if N is divisible by 3 or 5, return nif n is not divisible by 3 or 5, return 0; lapply results to vector; sum vector

It was like that. 

Native language for "is result an interger" is does modulus operator return 0.
```{r}
rm(list = ls())
EulerProblem1<-function(x){
numbers=1:x
total=rep(0,x)
for (i in numbers){
  if(i %% 3 == 0){
    total[i] <-i}
  else if (i %% 5 == 0) {
    total[i] <- i}
}
sum(total)
return(sum(total))
  }

EulerProblem1(999)  ## 233168, which is correct. Good!
## Could this have been done faster with sapply? Probably. 

```

### Euler Problem 2

**Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:**

**1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...**

**By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.**

Build a fibonaci sequence generator, then count all the numbers that are divisible by 2, then nest that in a loop that stops when the top value is 4*10^6.

```{r fibonnaci}
rm(list=ls())

## This works
numbers <- 1:32
N <- length(numbers)
total <- rep(0,N)
for (i in numbers){
  if(i %% 2 == 0) total[i] <-i
  }
total
sum(total) #272

## does this?
numbers <- seq(1,64,by = 5)
N <- length(numbers)
total <- rep(0,N)
for (i in numbers){
  if(i %% 2 == 0) total[i] <-i
  }
total
sum(total) 
## doesn't work, has a bunch of NAs. So that person is right, it's about assignment.


## This fibbonaci sequence works
Fibb<-function(x){
  y <- 1:x
  y[1] = 1
  y[2] = 2
  for (i in 3:x){
    y[i] <- y[i-2] + y[i-1]
  }
  return(y)
}
## But the same "sum evens" syntax doesn't work 
numbers <- Fibb(32) #  1, 2, 3, 5, 8,13, 21...
N <- length(numbers)
total <- rep(0,N)
for (i in seq_along(numbers)) {
    if(numbers[i] %% 2 == 0) total[i] <-i
}
total
sum(total)
 for (i in numbers){ # wrong
   if(i %% 2 == 0) total[i] <-i # wrong
 }
 total ## large numeric, bunch of zeroes and NAs
sum(total) #NA

## This works though
is.even <-function(x) { x %%2 == 0}
EvenFibs <- is.even(numbers)
qq <- sum(numbers[EvenFibs])

cat("the result is" , qq , ".\n")
## This is cool but didn't use it
##  last <- function(x) { tail(x, n = 1) }



```

## Euler Problem 3

** The prime factors of 13195 are 5, 7, 13 and 29.** 

** What is the largest prime factor of the number 600851475143 ? **

Let's practice a few concepts: while loops look llike 
`x <- 1`
`while(x < 5) {x <- x+1; if (x == 3) break; print(x); }`

and the ifelse syntax is 
` a <- 5`
`ifelse(a %/% 2 == 0, "even", "odd")`

Of course there is an answer on the internet:
`pacman::p_load(gmp)`
`max(gmp::factorize(n = 600851475143)) # 6857`

```{r Largest_Prime_Factor}
# Giving this another shot on 5/17/17
rm(list = ls())
PrimeNumGen <- function(x){
    r <- 2
  while( r <= sqrt(x) ){ # If r > sqrt(x), then x is prime
  ifelse(x %% r == 0,
         x <- x / r, 
         r <- r + 1)
    }
   return(x)
}
system.time(PrimeNumGen(600851475143))
PrimeNumGen(37)
```

### Problem 4
A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.

Find the largest palindrome made from the product of two 3-digit numbers.

```{r Palindrome}
PalindromeFinder <- function(digit){
  # Look up some math theory about finding the max of something.
  # intuitively, two vectors, x and y each length 3. You search 
  # for all palindromes where x is 999 by moving in 
  # descending order from 999 in y; when you get to the first palindrome,
  # that's the bound for x beneath which you don't need to check maxes. 
  # This is hard. 
  x <- rep_len(NA, digit)
  y <- rep_len(NA, digit)
  return(c(x, y))
}
PalindromeFinder(3)

```